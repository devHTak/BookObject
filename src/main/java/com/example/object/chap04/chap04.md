#### 설계 품질과 트레이드오프

##### 설계 트레이드오프

- 캡슐화
  - 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 종류
  - 변경될 가능성이 높은 부분을 구현이라고 하고, 안정적인 부분을 인터페이스라고 한다.
    - 구현과 인터페이스를 분리하고 외부에는 인터페이스만 의족하도록 관계를 조절하는 것
- 응집도와 결합도
  - 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 말한다.
  - 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타낸다.
  - 높은 응집도와 낮은 결합도를 갖는 것이 좋은 설계 방법이다.
  - 높은 응집도
    - 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정
    - 응집도가 높다면 모듈 전체를 함께 변경하는 것이고, 일부만 변경된다면 응집도가 낮은 것이다.
  - 낮은 결합도
    - 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
- 캡슐화의 정도가 응집도와 결합도에 영향을 미친다.

#### 문제점

- Getter/Setter
  - Getter/Setter 메소드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.
    - 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노출하게 된다.
  - Getter/ Setter를 생서할 때에는 막연한 추측을 기반으로 남용하는 것보다 필요에 의해 사용하는 것이 좋다.

- 높은 결합도
  - ReservationAgency
    ```java
    if(discountable) {
      // ...
      fee = movie.getFee().minus(discountAmount).times(audienceCount);
    } else {
      fee = movie.getFee();
    }
    ```
    - movie.getFee()는 Money가 return type인 데, 만약 요금에 대한 타입이 변경되면 ReservationAgency 소스도 수정되어야 한다.
    - 즉, getFee() 메소드는 fee를 정상적으로 캡슐화하지 못한다.
  - 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다.
    - DiscountCondition 이 수정되면 ReservationAgency 또한 같이 수정하게 된다.

- 낮은 응집도
  - 현재 설계는 새로운 할인 정책, 새로운 할인 조건을 추가하기 위해 하나 이상의 클래스를 동시에 수정해야 한다.
  - SRP
    - 단일 책임 원칙
    - 모듈의 응집도가 변경과 연관이 있기 때문에 SRP는 클래스에 변경 이유는 단 한가지만 가져야 한다는 의미다.
    - 즉, 책임은 맥락상에서 변경의 이유가 된다.

#### 자율적인 객체를 향하여

- 캡슐화
  - 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개하면 안된다.
  - 객체는 스스로의 상태를 책임지고 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.
    - 객체에 의미 있는 메서드는, 객체가 책임져야 하는 무언가를 수행하는 메서드
  - 변할 수 있는 어떤 것이라도 감추는 것. 
    - 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화 위반

- 스스로를 책임지는 객체
  - 객체 설계할 때 필요한 두가지 질문
    - 이 객체는 어떤 데이터를 포함해야 하는가?
    - 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

#### 데이터 중심 설계의 문제점

- 데이터 중심 설계는 객체의 행동보다 상태에 초점을 맞춘다.
- 데이터 중심 설계에서는 협력이라는 문맥을 고려하지 않고, 객체를 고립시킨 후에 오퍼레이션을 결정한다.