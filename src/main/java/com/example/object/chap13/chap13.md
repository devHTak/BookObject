#### 서브클래싱과 서브타이핑

- 상속의 용도
  - 타입계층
    - 부모클래스는 자식클래스의 일반화(Generalization)이고 자식클래스는 부모클래스의 특수화(Specialization)이다.
  - 코드 재사용
    - 간단한 선언만으로 부모의 코드 재사용이 가능하며 점진적으로 확장이 가능하다
    - 다만 강한 결합을 보이기 때문에 변경이 어려운 코드를 얻게 될 확률이 높다.

##### 타입

- 개념관점의 타입
  - 개념 관점에서 타입이란 인지하는 세상의 사물의 종류를 의미
  - 그 대상의 타입을 인스턴스, 객체라 부른다
  - 타입은 심볼, 내연, 외연 세가지 요소로 구성된다.
    - 심볼
      - 타입에 이름을 붙인 것으로 프로그래밍 언어가 타입의 심볼에 해당한다
    - 내연
      - 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다.
      - 프로그래밍 언어의 정의인 컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합이 바로 내연
      - 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성
    - 외연
      - 타입에 속하는 객체들의 집합
      - 프로그래밍 언어의 타입의 경우에는 자바, 자바스크립트가 속한 집합이 외연을 구성

- 프로그래밍 언어 관점의 타입
  - 프로그래밍 언어 관점의 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용
  - 두가지 목적
    - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥 제공

- 객체지향 패러다임 관점의 타입
  - 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다
  - 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다

##### 타입 계층

- 타입 사이의 포함관계
  - 타입계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입이라 부르고 더 특수한 타입을 서브타입이라고 부른다.
  - 일반화와 특수화
    - 일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
    - 특수화는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
  - 슈퍼타입 특징
    - 집합이 다른 집합의 모든 멤버를 포함
    - 타입 정의가 다른 타입보다 더 일반적이다.
  - 서브타입 특징
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함
    - 타입정의가 다른 타입보다 좀 더 구체적이다

- 객체지향 프로그래밍과 타입 계층
  - 퍼블릭 인터페이스 관점에서 슈퍼타입과 서브타입 정의
    - 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
    - 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것

##### 서브클래싱과 서브타이핑

- 언제 상속을 사용해야 하는가?
  - 다음과 같은 질문에 모두 YES로 대답할 수 있는 경우 상속을 사용
    - 상속 관계가 is-a 관계를 모델링하는가
      - 자식클래스는 부모클래스다라고 말해도 이상하지 않다면 상속을 사용할 후보가 될 수 있다.
    - 클라이언트 입장에서 부모클래스의 타입으로 자식클래스를 사용해도 무방한가
      - 상속 계층을 사용하는 클라이언트의 입장에서 부모클래스와 자식클래스의 차이점을 몰라야 하며 이를 행동 호환성이라고 부른다
- is-a 관계
  - is-a 관계 예시
    - 팽귄은 새다
    - 새는 날 수 있다
    ```java
    public class Bird{ public void fly() {...} }
    public class Penguin extends Bird { ... }
    ```
    - 이는 펭귄도 날수있다가 되므로 되지 않는다
  - 어휘적인 정의가 아닌 기대되는 행동에 따라 타입 계층을 구성해야 하는 사실을 보여준다.
    - 어휘적으로 펭귄은 새지만 만약 새의 정의에 날수있다는 행동이 포함된다면 펭귄은 새의 서브타입이 될 수 없다.
  - 타입 계층의 의미는 행동이라는 문맥에 따라 달라지며 올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다.

- 행동 호환성
  - 행동의 호환여부를 판단하는 기준은 클라이언트의 관점
  - 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다
  - Bird와 Penguin 예시
    ```java
    public class Penguin extends Bird {
      /**
      * 첫번째 방법: 메서드 내부 구현을 비워두는 것 -> 호환되지 않는다.
      */
      @Overriding
      public void fly() {}
      
      /**
      * 두번째 방법: 예외 발생 -> 호환되지 않는다.
      */
      @Overriding
      public void fly() { throw new UnsupportedOperation(); }
      
    }
    /**
    * 세번째 방법: Penguin 타입이 아닌 경우만 호출 -> 호환되지 않는다.
    */
    public void flyBird(Bird bird) {
      if( !(bird instanceof Penguin) ) {
        bird.fly();
      }
    }    
    ```

- 클라이언트의 기대에 따라 계층 분리하기
  - 해결방법1. 클라이언트의 기대에 맞게 상속 계층을 분리
    - Bird, Penguin, FlyingBird
      - 새에는 날 수 있는 새와 없는 새로 분리
      ```java
      public class Bird {}
      public class FlyingBird extends Bird { public void fly() {} }
      public class Penguin extends Bird {} // fly() 퍼블릭 인터페이스를 갖지 않게 된다

      -- client
      public void flyBird(FlyingBird bird) { bird.fly();}
      ```
  - 해결방법2. 클라이언트에 따라 인터페이스 분리
    - Flyer, Walker 인터페이스 분리
    - Bird는 Flyer, Walker 인터페이스 구현, Penguin은 Walker 인터페이스 구현
    - 하지만 Penguin 이 Bird의 코드를 재사용해야 하기 위해 Bird를 상속하면 Flyer 인터페이스에 fly오퍼레이션이 추가되기 때문에 위험하다
  - 해결방법3. 합성 사용
    - Bird를 재사용하기 위해 Penguin은 Bird를 재사용할 수 있다.

- ISP(Interface Segregation Principle, 인터페이스 분리 원칙)
  - 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙

- 서브클래싱과 서브타이핑
  - 서브클래싱
    - 코드를 재사용할 목적으로 상속을 사용하는 경우
    - 구현상속 또는 클래스상속이라고 부르기도 한다
  - 서브타이핑
    - 타입계층을 구성하기 위해 상속을 사용하는 경우
    - 인터페이스 상속이라고 부르기도 한다
  - 서브타이핑관계가 유지되기 위해서는 행동호환성을 만족해야 하며 이는 부모클래스에 대한 자식클래스의 대체가능성을 포함한다

##### 리스코프 치환 원칙

- 리스코프 치환 원칙(Liskov Substitution Principle)
  - 서브타입은 그것의 기반타입에 대해 대체 가능해야 한다는 것으로 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다는 것
  - 자식클래스가 부모클래스와 행동호환성을 유지함으로써 부모클래스를 대체할 수 있도록 구현된 상속 관계만이 서브타이핑이라고 불러야 한다.

- 클라이언트와 대체 가능성
  - 자식클래스가 부모클래스를 대체하기 위해서 부모클래스에 대한 클라이언트의 가정을 준수해야한다는 것을 강조한다.
  - Stack과 Vector가 서브타이핑 관계가 아닌 서브클래싱 관계, LSP 위반인 이유도 상속으로 인해 Stack에 포함되지 말아야 할 Vector에 퍼블릭 인터페이스가 포함됐기 때문이다

- is-a 관계 다시 살펴보기
  - 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계이며, 서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 말할 수 없다.

- 리스코프 치환 원칙은 유연한 설계의 기반이다
  - LSP는 클라이언트가 어떤 자식클래스와도 안정적으로 협력할 수 있는 상속구조를 구현할 수 있는 가이드라인을 제공한다.
  - OCP 는 LSP를 잘 지켰다면 행동 호환성을 유지하기 때문에 지켜지며 확장 가능하게 만들어 진다

- 타입계층과 리스코프 치환 원칙
  - 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나일 뿐이다.
  - 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용돼야 한다는 것

##### 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계(Design By Contact)
  - 클라이언트와 서버 사이의 협력을 의무(obligation)와 이익(benefit)으로 구성된 계약의 관점에서 표현하는 것
  - 세가지 요소
    - 계약에 의한 설계는 클라이언트가 정상적으로 메서드를 실행하기 위해 만족해야 하는 사전조건
    - 메서드 실행 전, 후에 서버가 클라이언트에게 보장해야 하는 사후조건
    - 메서드 실행 정, 후에 인스턴스가 만족시켜야 하는 클래스불변식
  - 서브타입이 리스코프치환원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.

- 서브타입과 계약
  - 계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식클래스가 부모클래스의 메서드를 오버라이딩할 수 있다는 것이다.
  - 사전조건
    - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
    - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
  - 사후조건
    - 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
    - 서브타입에 더 약한 사후조건을 정의할 수 없다
