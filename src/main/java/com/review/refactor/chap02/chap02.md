#### chapter 2. 리팩터링 원칙

##### 리팩터링 정의
- 리팩터링 용어는 명사, 동사로 사용할 수 있다.
  - 명사: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
  - 동사: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용하여 소프트웨어를 재구성한다
- 리팩터링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어 내는 일

##### 두 개의 모자
- 소프트웨어 개발의 목적을 '기능 추가', '리팩터링' 으로 두고 작업을 하며, 개발을 진행할 때 두개의 모자를 자주 바꿔쓰며 진행한다.
- 두개의 모자에는 작업 방식의 차이를 인식해야 한다

##### 리팩터링 하는 이유
- 리팩터링하면 소프트웨어 설계가 좋아진다
  - 내부 아키텍처를 충분히 이해하지 못한 채 코드를 수정하면 기반 구조가 무너지기 쉽다
  - 규적인 리팩터링은 코드의 구조를 지탱해준다
		
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다
  - 리팩터링을 통해 코드의 목적이 더 잘 드러나게, 의도를 명확하게 전달할 수 있도록 개선하자
		
- 리팩터링하면 버그를 쉽게 찾을 수 있다
  - 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다
  - 프로그램 구조를 명확하게 다듬으면 버그를 지나칠 수 없을 정도까지 명확해진다.
		
- 리팩터링하면 프로그래밍 속도를 높일 수 있다 
  - 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다
  - 모듈화가 잘되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다
  - 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기 쉽다

##### 언제 리팩터링해야 할까?

```
3의 법칙
	1. 처음에는 그냥 한다
	2. 비슷한 일을 두번째로 하게되면 일단 계속 진행한다
	3. 비슷한 일을 세번째 하게되면 리팩터링한다
```
- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기 
  - 리팩터링하기 가장 좋은 시점은 현재 코드 분석 등을 하는 기능을 새로 추가하기 직전이다
    - 함수를 복제해서 해당값만 수정하여 요구사항을 해결하는 경우
      - 리팩터링 모자를 쓰고 함수 매개변수화하기를 통해 리팩터링을 진행하자
    - 오류를 일으키는 코드가 세곳에 복제되어 있다면
      - 한곳으로 합치는 편이 작업하기 훨씬 편하다
  - 준비를 위한 리팩터링으로 상황을 개선하면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수 있다

- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
  - 코드를 파악할 때마다 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 확인한다
  
- 쓰레기 줍기 리팩터링
  - 비효율적으로 처리하는 경우 약간 절충을 해야 한다
    - 로직이 복잡하거나
    - 매개변수화한 함수 하나면 될 것을 여러 개로 작성했거나
  - 많은 시간이 할애된다면 수정 부분을 쪼개어 수정하며 좀 더 깔끔하고 정리될 수 있도록 하자
		
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 리팩터링을 수행하는 시간을 따로 잡지 않고, 개발을 진행하는 중에 처리한다
  - 잘 작성된 코드도 리팩터링을 거쳐야 한다
    - 기준이 변경되어 수정을 하게 될 때에도 이미 깔끔하다면 리팩터링하기 더 쉽다

- 오래 걸리는 리팩터링
  - 리팩터링에 너무 오랜 시간을 할애하여 하는 것보다 조금씩 해결해가는 편이 효과적일 때가 많다
  - 리팩터링해야 할 ㄹ코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식
		
- 코드 리뷰에 리팩터링 활용하기
  - 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에 도움이 된다
		
- 리팩터링하지 말아야 할 때
  - 외부 API 다루듯 호출하여 쓰는 코드는 리팩터링하지 않는다
  - 리팩터링하는 것보다 처음부터 다시 작성하는 것이 쉬울 때 하지 않는다
    - 하지만 어느쪽이 빠르고 쉬운지 판단하기 어렵다

##### 리팩터링 시 고려할 문제
- 새 기능 개발 속도 저하
  - 기능 추가 준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게할 수 있다
  - 리팩터링을 단순히 코드베이스를 예쁘게 꾸미는 것이 아닌 개발 기간을 단축하고자 하는 것이다
		
- 코드 소유권
  - 코드 소유권이 나누어 있으면 클라이언트에 영향을 주지 않고서 원하는 형태로 변경할 수 없기 때문에 리팩터링에 방해가 된다
  - 하지만 할 수 없는 것은 아니며 제약이 따를 뿐이다
  - 코드 소유권을 느슨하게 정하는 방식이 리팩터링이 잘 될 수 있도록 하자

- 브랜치
  - CI: Continuous Integration 지속적 통합
    - CI에 따르면 모든 팀원이 하루에 최소 한번은 마스터와 통합하도록 한다
    - 이렇게 하면 머지의 복잡도를 낮출 수 있다
    - 하지만 마스터를 건강하게 유지하고, 거대한 기능을 쪼개는 법을 배우고 각 기능을 끌 수 있는 기능 토글을 적용하도록 해야 한다
  - CI와 리팩터링 기법은 잘 맞는다

- 테스팅
  - 리팩터링 하기 전과 후 기능은 동일해야 한다
    - 실수로 인해 동작이 깨지지 않아야 한다
    - 리팩터링을 진행 도 중 버그 생성
  - 이러한 오류를 잡기 위해 자가 테스트 코드를 갖춰야 한다
		
- 레거시 코드 
  - 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기 어렵다
    - 테스트 보강
  - 레거시 코드 리팩터링 방식
    - 서로 관련된 부분끼리 나누어 하나씩 공략
    - 코드를 읽을 때 이전보다 조금이라도 개선하기 위한 노력
    - 많이 보는 부분을 더 많이 리팩터링하자

##### 리팩터링, 아키텍처, 애그니(YAGNI)
- 리팩터링은 기존 코드의 설계를 개선할 수 있다. 
  - 레거시 코드에 리팩터링을 하려면 탄탄한 테스트가 뒷받침해주어야 한다
  - 리팩터링이 아키텍처에 미치는 영향은 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 것
  
- 리팩터링은 어느 부분에 유연성이 필요하고 어떻게 그 변화에 대응할 지 추측하지 않고 현재까지 파악한 요구사항을 해결하는 구축한다. 
  - 단, 이 요구를 멋지게 해결하도록 설계하고 추후 요구사항이 바뀌면 그에 맞게 리팩터링해서 바꾸는 것
  
- 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가
  - 애그니(YAGNI, You Aren't Going to Need It), 간단한 설계, 점진적 설계

##### 리팩터링과 소프트웨어 개발 프로세스
- Agile 소프트웨어 방법론 
  - XP(익스트림 프로그래밍)의 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스로 애자일 부흥을 이끌었다
  
- 지속적 통합, 자가 테스트 코드, 리팩터링이라는 세 기법은 강력한 상승효과를 이룬다 
  - 애그니 설계 방식으로 진행 가능하게 한다
  
- 지속적 배포는 소프트웨어를 언제든 릴리스할 수 있는 상태로 유지해준다 
  - 기술적 제약보다 비즈니스 요구에 맞춰 릴리스 일정을 계획할 수 있다

##### 리팩터링과 성능
- 성능 vs 직관적 설계
- 성능을 위한 첫번째 방법 
  - 리팩터링하면 소프트웨어가 느려질 수 있지만 성능을 튜닝하는 것은 더 쉬워진다 
  - 먼저 튜닝하기 쉽게 만든 후 원하는 속도가 나게끔 튜닝하는 것

- 성능을 위한 두번째 방법 
  - 끊임없이 관심을 기울이는 것 
  - 코드 수정 시 어려운 형태로 변할 수 있기 때문에 효과는 변변치 않다. 

- 성능을 위한 세번째 방법 
  - 90%의 시간은 낭비라는 통계
    - 성능을 잡아먹는 부분은 극히 일부에서 발생하며 코드 전체를 고르게 최적화하는 것 중 90%는 효과가 없다는 것
  - 시간을 낭비하지 말고 의도적으로 성능 최적화에 돌입하기 전까지 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는 것에 집중한 후, 성능 최적화 단계가 되면 다음의 절차로 튜닝 진행
    - 성능에 영향을 주는 작은 부분을 찾는다
    - 해당 부분을 개선, 최적화하는 데 집중하며 리팩터링할 때와 마찬가지로 작은 단계로 나누어 진행
    - 각 단계마다 컴파일과 테스트를 거치며 성능을 확인한다
    - 성능 개선이 되지 않으면 수정 내용을 되돌린다
  - 리팩터링의 최적화 효과
    - 성능 튜닝에 투입할 시간을 벌 수 있다
    - 리팩터링이 잘되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다