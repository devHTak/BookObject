#### 기능 이동

##### 함수 옮기기

```java
class Account {
	public int getOverDraftCharge() {…}
}
```
```java
// Account 클래스에서 AccountType 클래스로 이동
class AccountType {
	public int getOverDraftCharge() {…}
}
```
- 배경 
  - 모듈성이란 프로그램의 어딘가를 수정하려할 때 해당 기능과 깊이 관련된 작은 부분만 이해해도 가능하게 해주는 능력으로 서로 연관된 요소들을 함께 묶고, 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 한다
  - 모든 함수(메서드)는 어떤 컨텍스트(클래스) 안에 존재한다 
    - 어떤 함수가 모듈 A의 요소보다 모듈 B의 요소르르 더 많이 참조한다면 모듈 B로 옮겨야 한다 
    - 이는 캡슐화가 좋아져 모듈의 세부사항에 덜 의존하게 된다 
  - 함수 옮기기 판단 기준을 위해서는 
    - 현재 컨텍스트와 후보 컨텍스트를 둘러보자 
    - 대상 함수를 호출하는 함수들은 무엇인지, 대상 함수가 호출하는 함수들은 무엇인지, 대상 함수가 사용하는 데이터는 무엇인지 살펴보자

- 절차 
  - 선택한 함수가 현재 컨텍스트에서 사용중인 모든 프로그램 요소를 살펴본다 
  - 선택한 함수가 다형메서드인지 확인한다
  - 선택한 함수를 타깃 컨텍스트로 복사한다.
  - 정적 분석을 실행
  - 소스 컨텍스트에서 타깃 함수를 참조할 방법을 찾아 반영
  - 소스 함수를 타깃 함수의 위임함수가 되도록 수정
  - 테스트
  - 소스 함수를 인라인할지 고민한다

##### 필드 옮기기
```java
class Customer {
	public Plan getPlan() { return this.plan; }
	public int getDiscountRate() { return this.discountRate; }
}
```
```java
// discountRate 필드를 Plan 클래스로 이동
class Customer {
	public Plan getPlan() { return this.plan; }
	public int getDiscountRate() { return this.plan.getDiscountRate(); }
}
```
- 배경 
  - 데이터 구조를 활용하면 동작 코드는 자연스럽게 단순하고 직관적으로 짜여진다
  - 함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 한다
  - 한 레코드를 변경하려 할 때 다른 레코드의 필드까지 변경해야 한다면 필드의 위치가 잘못된 것이다
  - 필드 옮기기 리팩터링을 진행하면 그 필드를 사용하던 많은 코드가 원래 위치보다 옮겨진 위치에서 사용하는 게 더 수월할 수 있기 때문에 호출 코드들까지 모두 변경해야 한다

- 절차 
  - 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다
  - 테스트
  - 타깃 객체에 필드와 접근자 메서드를 생성
  - 정적 검사 수행
  - 소스 객체에서 타깃 객체를 참조할 수 있는지 확인
  - 접근자들이 타깃 필드를 사용하도록 수정
  - 테스트
  - 소스 필드 제거
  - 테스트

##### 문장을 함수로 옮기기
- 배경
  - 반복되는 부분을 피호출 함수로 합치면 추후 반복되는 부분에서 문가 수정할 일이 생겻을 때 단 한곳만 수정하면 된다
  - 반대에 경우 문장을 호출한 곳으로 옮기기를 사용할 수 있다

- 절차
  - 반복 코드가 함수 호출 부분과 멀리 떨어져 있다면 문장 슬라이드하기를 적용해 근처로 옮긴다
  - 타깃 함수를 호출하는 곳이 한곳뿐이면, 단순히 소스 위치에서 해당 코드를 잘라내여 피호출 함수로 복사하고 테스트한다. 이 경우라면 나머지 단계는 무시한다
  - 호출자가 둘 이상이면 호출자 중 하나에서 타깃함수 호출 부분과 그 함수를 옮기려는 문장들을 함께 다른 함수로 추출한다. 추출한 함수에 기억하기 쉬운 임시 이름을 지어준다
  - 다른 호출자 모두가 방금 추출한 함수를 사용하도록 수정. 하나 수정할 때마다 테스트
  - 모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인한 후 원래 함수 제거
  - 새로운 함수의 이름을 원래 함수의 이름으로 바꿔준다

##### 문장을 호출한 곳으로 옮기기

- 배경
  - 함수는 추상화의 기본 블록이며 코드베이스의 기능 범위가 달라지면 추상화의 경계도 움직이게 된다
    - 초기에 한가지만 하던 함수가 둘 이상의 다른 일을 수행하게 바뀔 수 있다는 것
  - 여러 곳에서 사용하던 함수가 일부에서 다르게 동작하도록 변경해야 한다면 달라진 동작을 함수에서 꺼내 해당 호출자로 옮겨야 한다
    - 문장 슬라이드를 적용하여 달라지는 동작을 함수의 시작 또는 끝으로 옮긴 다음, 호출한 곳으로 옮기기 리팩터링을 적용하면 된다
    
- 절차
  - 호출자가 한두개 뿐이고 피호출 함수도 간단한 단순한 상황이면, 피호출 함수의 처음줄을 잘라내어 호추랒로 복사해 넣는다. 테스트를 통과하면 리팩터링 종료
  - 더 복잡한 상황에서는 이동하지 않길 원하는 모든 문장을 함수로 추출한 다음 검색하기 쉬운 이름을 지어준다
  - 원래 함수를 인라인 한다
  - 추출된 함수의 이름을 원래 함수의 이름으로 변경

##### 인라인 코드를 함수 호출로 바꾸기

```java
boolean appliesToMass = false;
for(String s: states) {
	if(s.equals("MA")) appliesToMass = true;
}
```
```java
boolean appliesToMass = states.contains("MA");
```
- 배경
  - 함수는 여러 동작을 하나로 묶어준다
  - 함수의 이름 코드의 동작 방식보다 목적을 말해주기 때문에 함수를 활용하면 코드 이해가 쉬워진다
  - 이름을 잘 지었다면 인라인 코드 대신 함수이름을 넣어도 된다
    - 이름이 적절하지 않다면 인라인 코드의 목적과 다르기 때문에 함수 호출로 대체하면 안된다

- 절차
  - 인라인 코드를 함수 호출로 대체
  - 테스트

##### 문장 슬라이드하기

- 배경
  - 관련된 코드들이 가까이 모여 있다면 이해하기 더 쉽다
  - 관련 코드들을 모드는 작업은 다른 리팩터링의 준비단계로 자주 행해지며 분리하기 쉬워진다

- 절차
  - 코드 조각을 이동할 목표 위치를 찾는다.
    - 코드 조각의 원래 위치와 목표 위치 사이의 코드를 훑어보며 조각을 모으고 나면 동작이 달라지는 코드가 있는지 살핀다. 
    - 해당 간선이 있다면 리팩터링 포기
      - 코드 조각에서 참조하는 요소를 선언하는 문장 앞으로는 이동할 수 없다
      - 코드 조각을 참조하는 요소의 뒤로 이동할 수 없다
      - 코드 조각에서 참조하는 요소를 수정하는 문장을 건너뛰어 이동할 수 없다
      - 코드 조각이 수정하는 요소를 참조하는 요소를 건너뛰어 이동할 수 없다
  - 코드 조각을 원래 위치에서 잘라내어 목표 위치에 넣는다
  - 테스트

##### 반복문 쪼개기

- 배경 
  - 반복문 하나에 여러 일을 수행하는 경우 반복문을 분리하면 사용하기 쉬워진다
  - 반복문 쪼개기는 서로 다른일을 한 함수에서 이뤄지고 있다는 신호가 되며 함수 추출하기를 연이어 수행하는 경우가 발생한다
  - 다만 반복문 쪼개기는 리팩터링과 최적화를 잘 구분하여 사용하자

- 절차
  - 반복문을 복제해 두개로 만든다
  - 반복문이 중복되어 생기는 부수효과를 파악하여 제거
  - 테스트
  - 완료됐으면, 각 반복문을 함수로 추출할 지 고민

##### 반복문을 파이프라인으로 바꾸기

- 배경
  - 컬렉션을 순회할 때 사용했던 반복문을 최근에는 컬렉션 파이프라인(스트림)을 이용하도록 변하고 있다

- 절차
  - 반복문에서 사용하는 컬렉션을 가리키는 변수를 하나 만든다
  - 반복문의 첫줄부터 시작하여 각각의 단위 행위를 적절한 컬렉션 파이프라인 연산으로 대체한다. 이 때 컬렉션 파이프라인 연산은 처음 만든 반복문 컬렉션 변수에서 시작하여, 이전 연산의 결과를 기초로 연쇄적으로 수행한다. 하나를 대체할 때마다 테스트한다
  - 반복문의 모든 동작을 대체했다면 반복문 자체를 지운다
    - 반복문 결과를 누적변수에 대입했다면 파이프라인의 결과를 그 누적 변수에 대입한다.

##### 죽은 코드 제거하기

- 배경
  - 사용되지 않는 코드에 의해 시스템이 느려지거나 메모리를 많이 잡아먹지는 않는다
  - 다만 소프트웨어를 이해하는 데 어려움을 준다

- 절차
  - 죽은 코드를 외부에서 참조할 수 있는 경우라면(함수 통째로 죽었을 때) 혹시라도 호출하는 곳이 있는지 확인한다
  - 없다면 죽은 코드를 제거한다
  - 테스트한다