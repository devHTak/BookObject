#### 코드에서 나는 악취
- 리팩터링하면 해결할 수 있는 문제의 징후

##### 기이한 이름 - Mysterious Name
- 코드를 명료하게 표현하는 데 가장 중요한 요소가 이름이다
  - 함수, 모듈, 변수, 클래스 등 이름만 보고 무슨 일을 하고, 어떻게 사용해야 하는 지 명확하게 표현해야 한다

- 마땅한 이름이 떠오르지 않는다면 설계에 근본적인 문제가 숨어있을 수 있다
  - 혼란스러운 이름을 정리하다보면 코드가 훨씬 간결해질 때가 있다.

##### 중복 코드 - Duplicated Code
- 똑같은 코드 구조가 여러 곳에 반복된다면 하나로 통합하자
- 함수추출하기: 한 클래스에 두 메서드가 똑같은 표현식을 사용하는 경우 양쪽 모두 추출된 메서드를 호출하도록 수정
  - 먼저 문장슬라이드하기로 비슷한 부분을 한곳에 모아 함수 추출에 더 쉽게 적용이 가능한지 살펴보자
- 메서드 올리기: 같은 부모로부터 파생된 클래스들에 코드가 중복되어 있으면 부모로 옮기자

##### 긴 함수 - Long Function
- 짧은 함수들로 구성된 코드베이스를 살펴보면 연산하는 부분보다 위임하는 방식으로 작성되어 있다
  - 간접호출의 효과를 얻을 수 있다.
  - 코드의 이해, 공유, 선택하기 쉬워진다
- 주석을 달아야 할 부분을 무조건 함수로 만들자
  - 함수명을 동작방식이 아닌 의도가 드러나게 함으로써 주석을 대체할 수 있다.
- 함수추출하기: 함수본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것
- 질의 함수로 바꾸기, 매개변수 객체만들기, 객체 통째로 넘기기: 매개변수가 많은 경우 사용
  - 여전히 임시변수와 매개변수가 많다면 함수를 명령으로 바꾸기를 고려해보자
- 조건문 분해하기
  - switch문은 case별 함수 추출하기나 조건부 로직을 다형성으로 바꾸기를 적용할 수 있다.
- 반복문 쪼개기
  - 그 안의 코드와 함께 추출해서 독립된 함수로 만든다
  - 반복문을 파이프라인으로 바꾸기를 적용하면 반복문 자체를 제거할 수도 있다.

##### 긴 매개변수 목록 - Long Parameter List
- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다. 
- 매개변수를 질의 함수로 바꾸기: 다른 매개변수에서 값을 얻어 올 수 있는 매개변수인 경우 사용 
- 객체 통째로 넘기기: 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 경우 사용
- 매개변수 객체 만들기: 항상 함께 전달되는 매개변수에 경우 사용
- 플래그 인수 제거하기: 함수의 동작 방식을 정하는 플래그 역할의 매개변수에 경우 사용
- 여러 함수를 클래스로 묶기: 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용하는 경우 사용

##### 전역 데이터
- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 수 없다.
- 변수 캡슐화하기: 전역 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있다. 

##### 가변 데이터
- 값을 다른 곳에서 설정할 수 있는 가변 데이터는 혼동과 버그를 일으키기 쉽다.
- 변수 캡슐화하기: 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 한다. 
- 변수 쪼개기: 용도별로 독립 변수에 저장하여 값 갱신이 문제를 일으킬 여지를 없앤다. 
- 질의 함수와 변경 함수 분리하기: 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없도록 한다. 
- 세터 제거하기: 변수의 유효범위를 줄인다. 
- 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기: 변수를 갱신하는 코드들의 유효범위를 제한한다. 
- 참조를 값으로 바꾸기: 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하도록 한다.

##### 뒤엉킨 변경 - Divergent Change
- 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경된다면 리팩터링의 대상이다.
- 단계 쪼개기: 순차적으로 실행하는 코드라면 단계를 분리한다.
- 함수 추출하기, 함수 옮기기: 각 맥락에 해당하는 모듈들을 만들어서 관련 함수들을 모은다.

##### 산탄총 수술 - Shotgun Surgery
- 코드를 변경할 때마다 변경할 부분이 코드 전반에 퍼져있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.
- 함수 옮기기, 필드 옮기기, 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기: 한 모듈에 묶어두도록 한다.
- 단계 쪼개기: 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 단계를 분리한다.
- 함수 인라인하기, 클래스 인라인하기: 분리된 로직을 하나로 합친다.
- 뒤엉킨 변경과 산탄총 수술
  ``` 
  - 공통점
    - 원인: 맥락을 잘 구분하지 못함
    - 해법(원인): 맥락을 명확히 구분
  - 차이점
    - 발생과정(현상)
      - 뒤엉킨변경: 한 코드에 섞여 들어감
      - 산탄총수술: 여러코드에 흩뿌려짐 
    - 해법(실제 행동)
      - 뒤엉킨변경: 맥락별로 분리
      - 산탄총수술: 맥락별로 모음
  ```
  
##### 기능 편애 - Feature Envy
- 모듈화할 때는 코드를 여러 영역으로 나눈뒤 영역 안에서 이뤄지는 상호작용을 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄여야 한다
  - 응집도와 결합도
- 기능편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터ㅘ 상호작용할 일이 더 많을 때 나타난다
- 함수 추출하기, 함수 옮기기: 필요한 데이터가 있는 클래스로 옮기거나, 필요한 부분을 독립함수로 추출한 뒤 원하는 모듈로 보내준다
- 전략 패턴과 방문자 패턴 사용

##### 데이터 뭉치 - Data Clumps
- 데이터 항목 중 몇 개가 여러 곳에서 항상 함께 뭉쳐서 사용될 경우 해당 데이터 뭉치는 새로운 객체로 분리하도록 한다.
- 클래스 추출하기: 필드 형태의 데이터 뭉치를 찾아 하나의 객체로 묶는다.
- 매개변수 객체 만들기, 객체 통째로 넘기기: 매개변수 수를 줄인다.

##### 기본형 집착 - Primitive Obsession
- primitive type을 그대로 사용하는 것보다 단위(금액, 물리량 등)에 맞게 사용하는 것이 좋다
- 기본형을 객체로 바꾸기
- 타입 코드를 서브클래스로 바꾸기, 조건부 로직을 다형성으로 바꾸기: 기본형 타입이 조건부 동작을 제어하는 타입 코드로 사용하는 경우
- 클래스 추출하기, 매개변수 객체 만들기: 기본형 그룹의 데이터 뭉치

##### 반복되는 switch문 - Repeated Switches
- 조건부 로직을 다형성으로 변경하기: 객체 지향을 좋아하는 사람에게 switch문으 다형성으로 바꾸는 것을 주장한다
  - if/else문도 동일하게 고민할 수 있다.
  
##### 반복문 - Loops
- 반복문을 파이프라인으로 바꾸기: stream의 map, filter등을 사용

##### 성의없는 요소 - Lazy Element
- 코드의 구조를 잡을 때 프로그램 요소(메서드, 클래스, 인터페이스 등)를 이용하는 것을 좋아한다
  - 구조의 변경, 재활용, 의미있는 이름등에 장점이 있다
  - 본문 코드를 그대로 쓰는 것과 동일한 경우, 클래스 하나의 하나의 메서드 밖에 없는 경우 등 불필요해지는 경우가 발생한다
- 함수 인라인하기, 클래스 인라인하기, 계층 합치기: 불필요한 부분을합치자

##### 추측성 일반화 - Speculative Generality
- 당장은 필요 없는 케이스 처리 로직 등을 미리 작성한 경우 나중에 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데없는 낭비일 뿐이다.
- 계층 합치기: 하는 일이 거의 없는 추상 클래스는 제거한다.
- 함수 인라인하기, 클래스 인라인하기: 쓸데없이 위임하는 코드는 삭제한다.
- 함수 선언 바꾸기: 본문에서 사용되지 않는 매개변수는 없앤다.
- 죽은 코드 제거하기: 사용되지 않는 코드는 제거한다.

##### 임시 필드 - Temporary Field
- 특정 상황에서만 값이 설정되는 임시 필드를 작성하면 코드는 이해하기 어렵다. 쓰이지 않는 것처럼 보이는 필드가 존재하는 이유에 대해서 파악해야 하기 때문이다.
- 클래스 추출하기, 함수 옮기기: 임시 필드들과 관련된 코드들을 한 군데에 몰아넣는다.
- 특이 케이스 추가하기: 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거한다.

##### 메시지 체인 - Message Chains
- 클라이언트가 한 객체를 통해 다른 객체를 얻고, 방금 얻은 객체에 또 다른 객체를 요청하는 경우
- 위임숨기기
- 함수 추출하기, 함수 옮기기: 결과 객체를 사용하는 코드 일부를 따로 빼낸 후 체인을 숨길 수 있는지 살펴보자

##### 중개자 - Middle Man
- 외부로부터 세부사항을 숨겨주는 캡슐화를 하는 과정에서 위임이 자주 활용된다
- 중개자 제거하기: 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있는 경우 사용하며 다른 클래스를 직접 사용하는 것이 좋다
  - 함수인라인하기: 위임 메서드를 제거한 후 남은 일이 없다면 사용

##### 내부자 거래 - Insider Trading
- 모듈 사이의 데이터 거래가 많으면 결합도는 높아진다. 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.
- 함수 옮기기, 필드 옮기기: 결합된 모듈들을 분리한다.
- 위임 숨기기: 공통 부분을 처리하는 제3의 모듈을 새로 만들거나 다른 모듈이 중간자 역할을 하도록 한다.
- 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기: 상속 관계에 있는 부모 자식 사이의 결합도를 낮춘다.

##### 거대한 클래스 - Large Class
- 한 클래스가 너무 많은 일을 하면 필드 수가 많아지고, 필드가 많을 경우 중복 코드가 생기기 쉽다.
- 클래스 추출하기, 슈퍼클래스 추출하기, 타입 코드를 서브클래스로 바꾸기: 필드 일부를 따로 묶어 개별 클래스 등으로 추출한다.

##### 서로 다른 인터페이스의 대안 클래스들 - Alternative Classes with Different Interface
- 클래스를 사용할 때의 장점으로는 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 점이다
  - 교체하려면 인터페이스가 같아야 한다
- 함수선언바꾸기: 메서드 시그니처를 일치하여 다형성 사용
- 함수 옮기기: 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어넣는다
- 슈퍼클래스 추출하기: 대안 클래스들 사이에 중복코드가 많아지는 경우 고려해보자

##### 데이터 클래스 - Data Class
- 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스
- 레코드 캡슐화: public 필드가 있는 경우 사용
- 세터제거하기: 변경하면 안되는 필드에 경우
- 데이터 클래스에 필요한 동작이 엉뚱한 곳에 정의돼 있는 경우, 클라이언트 코드를 데이터 클래스로 옮기자
  - 예외 사항으로는 다른 함수를 호출해 얻은 결과 레코드(데이터 객체)로는 동작 코드를 넣을 이유가 없다

##### 상속 포기 - Refused Bequest
- 서브클래스는 부모로부터 메서드와 데이터를 물려받는다.
  - 유산을 원치 않거나, 필요 없는 경우 사용
- 메서드 내리기, 필드 내리기: 계층 구조를 잘못 설계한 경우, 같은 계층에 서브클래스를하나 새로 만들어 물려받지 않을 부모 코드를 새로 만든 서브클래스로 넘긴다
- 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기: 부모의 동작이 필요하지만 인터페이스를 따르지 않아야 할 때 사용

##### 주석 - Comments
- 주석을 달면 안되는 것이 아니라 주석을 장황하게 많이 다는 것이 문제다.
- 함수 추출하기: 특정 코드 블록이 하는 일에 주석을 남기고 싶은 경우 
- 함수 선언 바꾸기: 이미 추출되어 있는 함수임에도 여전히 설명이 필요한 경우
- 어서션 추가하기: 시스템이 동작하기 위한 선행조건을 명시하고 싶은 경우