#### API 리팩터링

##### 질의 함수와 변경 함수 분리하기

```java
public int getTotalOutstandingAndSendBill() {
	int result = customer.getInvoices().stream().map(invoice -> invoice.getAmount())
		.reduce((total, each) -> total += each);
	sendBill();
	return result;
}
```
```java
public int totalOutstanding() {
	return customer.getInvoices().stream().map(invoice -> invoice.getAmount())
		.reduce((total, each) -> total += each);
}
public void sendBill() {
	emailGateway.send(formatBill(customer));
}
```

- 배경
  - 외부에서 관찰 가능한 겉보기 부수효과 없이 값을 반환해주는 함수를 추구해야 한다 
    - 질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다(명령-질의 분리)
  - 값을 반환하면서 부수효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하려고 시도하자
 
- 절차
  - 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다
  - 새 질의 함수에서 부수효과를 모두 제거한다
  - 정적 검사를 수행
  - 원래 함수를 호출하는 곳을 모두 찾아낸다
    - 호출하는 곳에서 반환 값을 사용한다면 질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래 줄에 새로 추가
    - 수정할 때마다 테스트
  - 원래 함수에서 질의 관련 코드를 제거
  - 테스트

##### 함수 매개변수화하기

```java
public void tenPercentRaise(Person person) {
	person.setSalary(person.getSalary() * 1.1);
}
public void fivePercentRaise(Person person) {
	person.setSalary(perosn.getSalary() * 1.05);
}
```
```java
public void raise(Person person, double rate) {
	person.setSalary(person.getSalary() * (1 + rate));
}
```

- 배경
  - 여러 함수가 비슷한 구조로 리터럴 값만 다르다면 그 다른 값을 배개변수로 받아 처리하는 함수로 중복을 없앨 수 있다.
- 절차
  - 비슷한 함수 중 하나를 선택한다
  - 함수 선언 바꾸기로 리터럴들을 매개변수로 추가
  - 이 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가
  - 테스트
  - 매개변수로 받은 값을 사용하도록 함수 본문 수정
    - 하나 수정할 때마다 테스트
  - 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정
    - 하나 수정할 때마다 테스트


##### 플래그 인수 제거하기 (매개변수를 메서드로 전환)

- 배경
  - 플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수
    - 플래그 인수는 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기 어려워 진다
  - 플래그 인수를 제거하면 코드가 깔끔해지며 프리미엄 로직 호출과 일반 로직 호출 차이를 더 쉽게 파악할 수 있게 된다

- 절차
  - 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적 함수들을 생성한다
  - 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정한다

##### 객체 통째로 넘기기

- 배경
  - 하나의 레코드에 값을 여러개를 가져와 인수로 넘기는 경우, 값들 대신 레코드를 통째로 넘기고 함수 본문에서 가져와 사용하도록 수정
    - 레코드를 통째로 넘기면 변화에 대응하기 쉽다
  - 한 객체가 제공하는 기능 중 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따라 묶어서 클래스로 추출하는 것이 좋다
  - 다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러개를 건네는 경우, 데이터 여러 개 대신 객체 자신의 참조만 건네도록 수정

- 절차
  - 매개변수들을 원하는 형태로 받는 빈 함수를 만든다
  - 새 함수의 본문에서 원래 함수를 호출하도록 하며 새 매개변수와 원래 함수의 매개변수를 매핑
  - 정적 검사 수행
  - 모든 호출자가 새함수를 사용하게 수정, 수정할 때마다 테스트
  - 호출자를 모두 수정했다면 원래 함수를 인라인 한다
  - 새 함수의 이름을 적절히 수정하고 모든 호출자에 반영

##### 매개변수를 질의 함수로 바꾸기

- 배경
  - 매개변수를 제거하면 값을 결정하는 책임 주체가 달라진다
    - 변수가 있다면 결정 주체가 호출자가 되고, 매개 변수가 없다면 피호출함수가 된다
  - 매개변수를 질의 함수로 바꾸지 말아야 할 상황은 매개변수를 제거하면 피호출 함수에 원치 않는 의존성이 생길 때다
  - 참조 투명이란 '함수에 똑같은 값을 건네 호출하면 항상 똑같이 동작한다'는 뜻
    - 동작 예측, 테스트하기 쉽기 때문에 매개변수를 없애는 대신 가변 전역 변수를 이용하는 일은 하면 안된다
			
- 절차 
  - 필요하다면 대상 매개변수의 값을 계산하는 코드를 별도 함수로 추출해놓는다
  - 함수 본문에서 대상 매개변수로의 참조를 모두 찾아 그 매개변수의 값을 만들어주는 표현식을 참조, 하나 수정할 때마다 테스트
  - 함수 선언 바꾸기로 대상 매개변수를 없앤다

##### 질의 함수를 매개변수로 바꾸기

- 배경 
  - 참조 투명성 (똑같은 값을 건네면 매번 똑같은 결과를 내느 함수)
    - 참조 투명하지 않은 원소에 접근하는 모든 함수는 참조 투명성을 잃게 되는데, 이 문제는 해당 원소를 매개변수로 바꾸면 해결된다
  - 단점으로는 질의 함수를 매개변수로 바꾸면 어떤 값을 제공할지를 호출자가 알아내야 한다.
    - 호출자가 복잡해진다
      
- 절차
  - 변수 추출하기로 질의 코드를 함수 본문의 나머지 코드와 분리한다
  - 함수 본문 중 해당 질의를 호출하지 않는 코드들을 별도 함수로 추출
  - 방금 만든 변수를 인라인하여 제거
  - 원래 함수도 인라인
  - 새 함수의 이름을 원래 함수의 이름으로 고쳐준다

##### 세터 제거하기

- 배경
  - 객체 생성 후 수정되지 않길 원하는 필드는 세터를 제공하지 않는다
    - 무조건 접근자 메서드를 통해 필드를 다루려고 할 때
    - 클라이언트에서 생성 스크립트를 사용해 객체를 생성 할 때
    
- 절차
  - 설정해야 할 값을 생성자에서 받지 않는다면 그 값을 받을 배개변수를 생성자에 추가
  - 생성자 밖에서 세터를 호출하는 곳을 찾아 제거, 대신 새로운 생성자를 사용
    - 하나 수정할 때마다 테스트
  - 세터 메서드를 인라인한다, 가능하다면 불면으로 만든다
  - 테스트

##### 생성자를 팩터리 함수로 바꾸기

```java
Engineer leadEngineer = new Engineer();
```
```java
Engine leadEngineer = factory.createENgineer();
```

- 배경
  - 새로운 객체를 생성할 때면 주로 생성자를 호출하지만 생성자에는 일반 함수에는 없는 제약이 발생한다
    - 팩터리 함수에는 제약이 없기 때문에 대체할 수 있다
    
- 절차
  - 팩터리 함수를 만든다. 팩터리 함수의 본문에서는 원래의 생성자를 호출
  - 생성자를 호출하던 코드를 팩터리 함수 호출로 바꾼다.
  - 하나씩 수정할 때마다 테스트
  - 생성자의 가시 범위가 최소가 되도록 제한한다.

##### 함수를 명령으로 바꾸기

- 함수를 그 함수만을 위한 객체 안으로 캡슐화하는 상황이 있는데, 이런 객체를 가리켜 명령 객체, 명령이라 한다
  - 객체 대부분은 메서드 하나로 구성되며, 이 메서드를 요청해 실행하는 것이 객체의 목적이다
- 명령은 평범한 함수 메커니즘보다 유연하게 함수를 제어하고 표현할 수 있다.
  - 보조 연산을 제공할 수 있으며, 수명 주기를 더 정밀하게 제어하는 데 필요한 매개변수를 만들어주는 메서드도 제공할 수 있다

##### 명령을 함수로 바꾸기

- 명령 객체는 복잡한 연산을 다룰 수 있는 메커니즘을 제공한다.
  - 큰 연산 하나를 여러 개의 작은 메서드로 쪼개고 필드를 이용해 쪼개진 메서드들끼리 정보를 공유할 수 있다.
- 명령의 로직이 복잡하지않다면 평범한 함수로 바꿔주는 게 낫다

##### 수정된 값 반환하기

- 배경
  - 데이터가 어떻게 수게되는 지 추적하는 일은 어려운 부분 중 하나다.
    - 어느 함수가 무슨일을 하는 지 쉽게 알 수 있게 하는 일이 중요하다
  - 좋은 방법으로는 변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것
    
- 절차
  - 함수가 수정된 값을 반환하게 하여 호출자가 그 값을 자신의 변수에 저장하게 한 후 테스트
  - 피호출 함수 안에 반환할 값을 가리키는 새로운 변수를 선언한 후 테스트
  - 계산이 선언과 동시에 이뤄지도록 통합한 후 테스트
  - 피호출 함수의 변수 이름을 새 역할에 어울리도록 바꾼 후 테스트

##### 오류 코드를 예외로 바꾸기

- 배경
  - 오류 코드를 사용하면 클라이언트에서 처리해주길 기대해야 한다
  - 예외를 사용하면 적절한 예외 핸들러를 통해 오류 상황에 대처할 수 있다.

- 절차
  - 콜스택 상위에 해당 예외를 처리할 에외 핸들러를 작성한 후 테스트
  - 해당 오류 코드를 대체할 예외와 그 밖의 예외를 구분할 식별 방법을 찾는다
  - 정적 검사를 수행
  - catch 절을 수정하여 직접 처리할 수 있는 예외는 적절히 대처하고 그렇지 않은 예외는 다시 던진 후 테스트
  - 오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정, 하나 수정할 때마다 테스트
  - 모두 수정했다면 그 오류 코드를 콜스택 위로 전달하는 코드를 모두 제거, 제거할 때마다 테스트

##### 예외를 사전확인으로 바꾸기

```java
public double getValueForPeriod(int periodNumber) {
	try {
		return values[periodNumber];
	} catch(ArrayIndexOutBoundsException e) {
		return 0;
	}
}
```
```java
public double getValueForPeriod(int periodNumber) {
	return (periodNumber >= values.length ? 0 : values[periodNumber]);
}
```

- 예외는 뜻밖의 오류라는 뜻으로 예외적으로 동작할 때만 사용해야 한다
- 함수 수행 시 문제가 될 수 있는 조건을 호출 전에 검사할 수 있다면 조건을 추가해야 한다