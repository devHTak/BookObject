#### 합성과 유연한 설계

- 상속은 is-a 관계, 합성은 has-a 관계라고 한다.
- 상속
  - 자식클래스는 부모클래스에 소스를 재사용할 수 있다.
  - 자식클래스는 부모클래스에 대해 많은 정보를 알기 때문에 결합도가 높아질 수 밖에 없다.
- 합성
  - 합성은 구현에 의존하지 않고 퍼블릭 인터페이스에 의존하기 때문에 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있다.

- 상속관계는 클래스 사이의 정적인 관계이지만 합성 관계는 객체 사이의 동적인 관계이다.
  - 상속은 코드 작성 시점에 관계를 결정하지만 합성관계는 실행 시점에 동적으로 변경할 수 있다.

- 재사용성
  - 상속은 부모클래스 안에 구현된 코드 자체를 재사용하지만 합성은 객체의 퍼블릭 인터페이스를 재사용한다

##### 상속을 합성으로 변경하기

- 상속에 세가지 문제점
  - 불필요한 인터페이스 상속 문제
  - 메서드 오버라이딩의 오작용 문제
  - 부모클래스와 자식클래스의 동시 수정 문제

- 불필요한 인터페이스 상속 문제
  - Stack 객체가 Vector를 상속받아 add와 같이 FIFO 원칙에 어긋나는 인터페이스를 제공했다.
  - 합성으로 해결할 수 있다.
    - Vector 객체를 인스턴스 변수로 선언한 후 필요한 인터페이스만을 사용
  - 예제: Stack.class

- 메서드 오버라이딩의 오작용 문제(InstrumentedHashSet)
  - Properties, Stack 와의 차이점은 InstrumentedHashSet은 몇가지를 제외하고 HashSet이 제공하는 퍼블릭 인터페이스를 그대로 제공해야 한다.
  - HashSet에 대한 결합도는 제거하면서 퍼블릭 인터페이스를 그대로 상속받는 방법으로 인터페이스를 상속받고 합성을 이용하자
  - 예제: InstrumentedHashSet.class
    - InstrumentedHashSet을 보면 HashSet의 내부 메서드를 그대로 사용했다
    - 이를 포워딩(forwarding)이라 하며 동일한 메서드를 호출하기 위해 추가된 메서드를 포워딩 메서드라 한다

- 부모클래스와 자식클래스의 동시 수정 문제
  - 상속이 아닌 합성을 사용해도 부모클래스와 자식클래스를 동시에 수정하는 문제가 발생한다.
  - 다만 합성을 사용하는 것이 좋다.
    - 부모클래스의 내부 구현을 변경하더라도 파급효과를 최대한 자식클래스 내부로 캡슐화할 수 있기 때문이다

##### 상속으로 인한 조합의 폭발적인 증가

- 상속으로 인해 결합도가 높아지면 코드를 수정하는 데 많은 양의 작업이 필요하게 된다
  - 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가, 수정해야 한다.
  - 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.

- 기본 정책과 부가 정책 조합
  - 핸드폰 과금 시스템에 새로운 요구사항 추가
    - 요금제에 부가 정책을 추가하는 것
  - 부가 정책 특성
    - 기본 정책의 계산 결과에 적용된다
    - 선택적으로 적용할 수 있다.
    - 조합 가능하다
    - 부가 정책은 임의의 순서로 적용 가능하다

- 기본 정책에 세금 정책 조합
  - 일반 요금제에 세금 정책 조합
    - RegularPhone 클래스를 상속받은 TaxableRegularPhone 클래스 추가
    - NightlyDiscountPhone 클래스를 상속받은 TaxableNightlyDiscountPhone 클래스 추가
  - Taxable... 클래스에서 세금 계산을 위해 부모의 calculatedFee 메서드를 오버라이딩 하여 계산 후 세금을 부가하는 로직으로 수정할 수 있지만, 이는 결합도를 높인다.
    ```java
    public class TaxableRegularPhone extends RegularPhone {
        // ...
    
        @Override
        pulbic Money calculatedCallFee(Call call) {
            Money fee = super.calculatedCallFee(call);
            return fee.plus(fee.times(taxRate));
        }
    }
    ```
  - 결합도를 낮추가 위해 AbstractPhone 에 afterCalculate(Money fee) 추상 메서드 추가
    - RegularPhone, NightlyDiscountPhone 에 의미없는 afterCalculate 를 구현해야 한다
    - AbstractPhone 에 구현 메서드로 선언하고 Taxable... 클래스에서 오버라이딩 하자

- 기본 정책에 기본 요금 할인 정책 조합
  - 기본 요금 할인 정책을 적용하기 위해 각각 RegularPhone, NightlyDiscountPhone를 상속받는 RateDiscountable.. 구현 클래스 구현
  - AbstractPhone 클래스에 afterCalculate 메서드 구현

- 중복코드의 덫
  - 상속을 이용한 해결방법은 모두 가능한 조합별로 자식클래스를 추가하는 방식이다.
  - 만약 할인 정책 하위에 추가적인 정책이 발생하면 상속클래스를 추가해야 하며 일일이 하나씩 자식클래스를 추가해야 한다
  - 클래스 폭발 또는 조합의 폭발 문제
    - 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우

##### 합성관계로 변경

- 상속을 사용하는 것은 컴파일 타임 의존성과 런타임 의존성을 동일하게 만드는 것
  - 상속을 사용하면 부모, 자식클래스의 관계가 정적으로 고정된다.
- 합성관계는 런타임에 동적으로 변경 가능
  - 합성을 사용하면 컴파일 타임, 런타임 의존성을 다르게 만들 수 있다.

- 기본정책 합성하기
  - Phone 내부에 RatePolicy 에 대한 참조자가 포함되어 있는 것을 합성이라 한다
  - 합성을 사용하면 Phone과 연결되어 있는 RatePolicy 인터페이스의 구현 클래스가 어떤 타입인지에 따라 요금 계산 하는 방법이 다르다.

- 부가정책 적용하기
  - 컴파일 시점의 Phone 클래스와 RatePolicy 인터페이스 사이의 관계가 런타임 Phone 인스턴스와 RegularPolicy 인스턴스로 변경된 것을 확인할 수 있다.
  - 부가정책 추가에 대한 제약 사항
    - 부가정책은 기본정책이나 다른 부가정책의 인스턴스를 참조할 수 있어야 한다. 다시 말해 부가 정책의 인스턴스는 어떤 종류의 정책과도 합성될 수 있어야 한다.
    - Phone 의 입장에서는 자신이 기본정책의 인스턴스에게 메시지를 전송하고 있는지, 부가정책의 인스턴스에게 메시지를 전송하고 있는지를 몰라야 한다. 다시 말해서 기본정책과 부가정책은 협력안에서 동일한 역할을 수행해야 한다. 이것은 부가정책이 기본정책과 동일한 RatePolicy 인터페이스를 구현해야 한다는 것을 의미한다.
  - 부가정책(AdditionalRatePolicy)를 추상클래스로 정의하며 RatePolicy 인터페이스 구현체로 정의
    - TaxablePolicy, RateDiscountablePolicy 구현
  - AdditionalRatePolicy 에 RatePolicy next 를 정의하여 기본정책을 적용한 후 부가정책이 적용될 수 있도록 하자 

- 새로운 정책 추가하기
  - 상속을 기반으로 한 설계에 새로운 부가정책을 추가하기 위해서는 상속계층에 불필요할 정도로 많은 클래스를 추가해야 했다.
  - 합성을 기반으로 하면 클래스 하나만 추가하여 사용할 수 있다.
    - 기본정책에 고정요금제 추가를 하기 위해서는 FixedRatePolicy extends BasicRatePolicy 구현
    - 부가정책에 약정할인정책을 추가하기 위해서는 AgreementDiscountablePolicy extends AdditionalRatePolicy 구현

- 객체합성이 클래스 상속보다 더 좋은 방법이다.
  - 상속을 사용해야 할 때
    - 구현 상속
    - 인터페이스 상속

##### 믹스인

- 합성이 상속과 같은 문제점을 초래하지 않는 이유는 클래스의 구체적인 구현이 아닌 객체의 추상적인 인터페이스를 의존하기 때문이다.
- 믹스인
  - 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법
  - 특정 행동을 실행해주는 메소드를 제공하는데 단독으로 쓰이지 않고 다른 클래스에 행동을 더해주는 용도로 사용된다.
  - 특정 기능만을 담당하는 클래스, 단독 사용이 아닌 다른 클래스에 사용될 목적으로 작성된 부품 같은 클래스를 의미하며 전통적인 다중상속을 클래스의 부분으로 쪼개어 조립하는 것


