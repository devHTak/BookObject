#### 유연한 설계

##### OCP

- OCP: 소프트웨어 개체는 확장에 대해 열려있고, 수정에 대해서는 닫혀있어야 한다.
  - 확장에 대해 열려 있다.
    - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
  - 수정에 대해 닫혀 있다.
    - 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
  - 런타임 의존성은 실행시에 협력에 참여하는 객체들 사이의 관계
  - 컴파일타임 의존성은 코드에서 드러나는 클래스들 사이에 관계
  - OCP를 수용하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.
    - Movie가 의존하는 DiscountPolicy를 살펴보면, Movie 수정없이 NonDiscountPolicy등을 추가하였다
    
- 추상화가 핵심이다
  - OCP에 핵심은 추상화에 의존하는 것이다.
  - 추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법
    - 문맥이 바뀌더라도 변하지 않는 부분만 남게되고, 문맥에 따라 변하는 부분은 생략한다.
    - 추상화를 통해 생략되는 부분은 확장의 여지를 남긴다
  - 폐쇄를 가능하게 하는 것은 의존성의 방향이며 수정에 대한 영향을 최소화하기 위해서는 추상화에 의존해야 한다.

##### 생성 사용 분리

- Movie가 오직 DiscountPolicy를 의존하기 위해서는 Movie 내부에 DiscountPolicy 구체 클래스의 인스턴스를 생성하는 것은 OCP를 위반하는 것
- 생성만 하고 메세지를 보내지 않거나, 메시지를 보내기만 하고 생성하지 않으면 괜찮다. 하지만 항상 둘은 공존하게 된다.
- 이를 해결하기 위해 생성과 사용을 분리해야 한다.

- Factory 추가하기
  - 생성 책임을 client로 옮긴 배경에는 특정 컨텍스에 묶여서는 안되지만 client는 묶여도 상관없다는 전제가 깔려있다.
  - 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 Factory라 부른다
    ```java
    public class Factory {
        public Movie createMovie() {
            return new Movie( ... );
        }
    }
    ```
    ```java
    public class Client {
        private Factory factory;
    
        public Client(Factory factory) {
            this.factory = factory;
        }
        public Money getMovieFee() {
            Movie movie = factory.createMovie();
            return movie.getFee();
        }
    }
    ```
    
- 순수한 가공물에게 책임 할당하기
  - 책임할당에 가장 원칙은 책임을 수행하는데 가장 많은 정보를 알고있는 INFORMATION EXPERT에게 할당하는 것이다
    - 도메인 모델은 INFORMATION EXPERT를 찾기위한 1차적인 재료며, 도메인 모델 중 책임 할당할 후보를 찾는다.
    - Factory는 도메인 모델에 속하지 않으며 순수한 기술적인 결정이다.
  - PURE FABRICATION
    - 모든 책임을 도메인에 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하 등의 이슈가 생길 수 있다.
    - 그렇기 때문에 도메인 개념을 표현한 객체가 아닌 설계자 편의를 위해 만든 객체를 말한다
  - PURE FABRICATION 패턴은 INFORMATION EXPERT 패턴에 따라 책임을 할당한 결과가 바람직하지 않을 경우 대안으로 사용
    - 많은 정보를 가진 도메인 객체에 책임을 할당하여도 낮은 응집도, 높은 결합도가 발생할 경우 사용

##### 의존성 주입(DI)

- 생성과 사용을 분리하면 Movie 에는 오로지 인스턴스를 사용하는 책임만 남게 된다
- 이 것은 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법으로 의존성 주입이라 한다
- 의존성 주입 3가지 방법
  - 생성자 주입
  - setter 주입
  - 메서드 (호출) 주입

- 숨겨진 의존성은 나쁘다 (Service Locator Pattern)
  - Service Locator는 의존성을 해결할 객체들을 보관하는 일종의 저장소
  - 외부에서 객체에게 의존성을 전달하는 의존성과 달리 Service Locator에게 의존성을 해결해줄 것을 요청
  - 단점으로는 의존성을 감춘다
    - 숨겨져 있기 때문에 의존성을 명시하는 것을 빠트릴 수 있고, 이는 NullPointException 같은 예외사항이 발생할 수 있기 때문이다
    - 이는 숨겨진 의존성이 캡슐화를 위반했기 때문이다.
  - 명시적 의존성이 숨겨진 의존성보다 좋다.

##### 의존성 역전 원칙

- 추상화와 의존성 역전
  - 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다
  - 의존성은 변경의 전파와 관련된 것이기 떄문에 설계는 변화의 영향을 최소화하도록 의존성을 관리해야 한다
  - 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상클래스, 인터페이스를 따라야 한다
    - 구체 클래스는 의존성의 시작점이어야 하며, 의존성의 목적지가 되어서는 안된다
  - 의존성 역전 원칙
    ```
    1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 다 모두 추상화에 의존해야 한다.
    2. 추상화의 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.
    ```
    
- 의존성 역전 원칙과 패키지
  - 객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다.
    - Java: 패키지를 이용해 모듈을 구현. C++, C#: 네임스페이스를 이용해 모듈을 구현
  - Seperated Interface Pattern
    - 추상화를 별도의 독립적인 패키지가 아닌 클라이언트가 속한 패키지에 포함시켜야 한다. 그리고 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다.
    - 예시
      - Movie, DiscountPolicy, AmountDiscountPolicy, PercentDiscountPolicy 가 있다
      - Movie, DiscountPolicy 를 한 패키지로 묶으면 Movie 를 특정한 컨텍스트로부터 완벽하게 독립시킨다.
        - DiscountPolicy는 추상화 클래스이고 이를 사용하는 client가 Movie 이다
      - AmountDiscountPolicy, PercentDiscountPolicy는 자식 클래스로 구현하기만 하면 상위 수준의 협력 관계를 재사용할 수 있기 때문에 같은 패키지로 묶일 필요가 없다.
  
##### 유연성에 대한 조언

- 유연한 설계는 유연성이 필요할 때만 옳다
  - 유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고, 동일한 컴파일타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계를 의미
  - 하지만 유연한 설계는 복잡성을 수반하며 유연하지 않은 설계는 단순하고 명확하다

- 협력과 책임이 중요하다
  - 설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다.
    - 다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 함께 사라진다.
    - 객체들이 메시지 전송자의 관점에서 동일한 책임을 수행 여부를 판단할 수 없다면 공통의 추상화를 도출할 수 없다
  - SINGLETON 패턴은 객체 생성에 너무 이른 시기에 고민하고 결정할 때 도입되는 경향이 있다.
    - 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다
  - 