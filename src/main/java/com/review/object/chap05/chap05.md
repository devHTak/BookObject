#### 책임할당하기

- 책임에 초점을 맞춰 설계할 때 가장 큰 어려움은 어떤 객체에 어떤 책임을 할당할 것인가이다.
- 책임 할당 과정은 일종의 트레이드오프로 다양한 관점에서 설계할 수 있고, 평가할 수 있어야 한다.
- GRASP 패턴은 책임할당의 어려움을 해결하기 위한 해답을 제공

##### 책임주도설계

- 데이터보다 행동을 먼저 결정하라
  - 클라이언트 입장에서 객체가 수행하는 행동이란 곧 객체의 책임을 의미한다.
  - 데이터는 객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐이다.

- 협력이라는 문맥안에서 책임을 결정하라
  - 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다.
    - 메시지를 결정하고 메시지를 누구(객체)에게 전송할 지 찾아야한다.
  - 메시지를 수신하기로 결정된 객체는 메시지를 처리할 '책임'을 할당받게 된다.

- 책임주도설계 흐름 정리
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악
  - 시스템 책임을 더 작은 책임으로 분할
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
  - 객체가 책임을 수행하는 도 중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.

##### GRASP

- General Responsibility Assignment Software Pattern
- 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것

- 도메인 개념에서 출발하기
  - 설계를 시작하기 전에 도메인에 대하여 개략적인 모습을 그려보는 것이 유용하다.

- 정보 전문가에게 책임을 할당하라
  - 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다.
  - 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫번째 객체를 선택하는 것으로 설계를 시작한다.
    - 메시지를 전송할 객체는 무엇을 원하는가?
    - 메시지를 수신할 적합한 객체는 누구인가?
  - Information Expert (정보전문가) 패턴
    - 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라
    - 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화를 유지할 수 있다.
    - 필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력있고, 결합도가 낮아진다.

- 높은 응집도와 낮은 결합도
  - LOW COUPLING(낮은 결합도)
    - 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?
    - 예제) DiscountPolicy가 협력대상으로 Movie 또는 Screening 중 무엇이 좋을까 
      - 이미 요금을 계산하기 위해서는 Movie와 DiscountPolicy와 협력하고 있기 때문에 Screening과 협력을 추가하기 때문에 결합도를 높이는 결과가 된다.
  - HIGH COHESION(높은 응집도)
    - 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가
    - 예제) DiscountPolicy가 협력대상으로 Movie 또는 Screening 중 무엇이 좋을까
      - Screening에 가장 중요한 책임은 예매를 생성하는 것으로 DiscountPolicy와 의존성을 맺게되면 가격계산이란 책임 일부를 떠안게 된다
      - 결과적으로 DiscountPolicy 가 변경되면 Screening에게 영향을 미치게 된다.

- 창조자에게 객체 생성 책임을 할당하라
  - CREATOR 패턴
    - 객체 A를 생성할 때 아래 조건을 최대한 만족하는 객체 B가 생성할 수 있도록 하자
      - B가 객체A를 포함하거나 참조한다.
      - B가 객체A를 기록한다.
      - B가 객체A를 긴밀하게 사용한다.
      - B가 객체A를 초기화하는 데 필요한 데이터를 가지고 있다.
    - 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.
    - 두 객체는 서로 결합된다.

- 다형성 패턴 (Polymorphism)
  - DiscountPolicy 객체
    - 하나 이상의 변경이유가 존재하기 떄문에 개선이 필요하다
      - 새로운 할인 조건 추가
      - 순번 조건 판단 로직 변경 대응
      - 기간 조건 판단 로직 변경 대응
    - 변경이유가 존재하면 응집도가 낮다.
    - 응집도가 낮다는 것은 서로 연관성이 없는 기능이나, 데이터가 하나의 클래스 안에 뭉쳐져 있다는 것을 의미한다.
    -변경의 이유에 따라 클래스를 분리해야 한다.
  - 단순하게 DiscountPolicy를 Sequence, Period로 타입을 나누게 된다면, 호출하는 Movie객체에 수정이 필요하게 된다.
    - 이를 해결하기 위해 다형성을 사용

  - 객체의 암시적 타입에 따라 행동을 분기해야 한다면 암시적인 타입을 명시적인 클래스로 정의하고 행동을 나눔으로써 응집도 문제를 해결할 수 있다.
  - 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라는 것

- 변경 보호 패턴(Protected Variations)
  - 변경을 캠슐화하도록 책임을 할당하는 것
    - 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당

  - 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스를 분해하고 다형성패턴에 따라 책임을 분산
  - 예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 변경보호패턴에 따라 안정적인 인터페이스 뒤로 변경을 캡슐화하라

- 상속과 합성
  - Movie 에서 MovieType 에 대하여 분기처리된 calculateDiscountAmount()를 상속으로 해결했다.
  - 상속은 실행중에 할인 정책이 변경하기 위해서 새로운 인스턴스를 생성한 후 필요한 정보를 변경해야 하며, 새로운 할인 정책이 추가될 때마다 새로운 인스턴스를 생성해야 한다.
  - 이를 해결하기 위해 합성을 사용하라
    - DiscountPolicy란 객체를 사용하여 Movie가 DiscountPolicy에게 해당 역할을 위임하라