#### Appenix A. 계약에 의한 설계

- 계약에 의한 설계를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있다

##### 협력과 계약

- 부수효과를 명시적으로
  - 프그래밍 언어로 작성된 인터페이스는 객체가 수신할 수 있는 메시지는 정의할 수 있지만 객체 사이의 의사소통 방식은 명확하게 정의할 수 없다.
  - Code Contracts 사용과 If 문 사용의 차이점은 대표적으로 문서화가 있다
  - 추가적으로 제약 조건의 만족 여부를 실행 중에 체크할 수 있다
- 계약
  - 계약의 일반적인 특징
    - 각 계약 당사자는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행한다
    - 각 계약 당사자의 이익과 의무는 계약서에 문서화된다
  - 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어

##### 계약에 의한 설계

- 협력에 참여하는 각 객체는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행한다
- 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스 상에 문서화된다
- 계약에 의한 설계를 구성하는 세가지 요소
  - 사전조건, 사후조건, 불변식
  - 기술할 때에 실행 절차를 기술할 필요 없이 상태 변경만을 명시하기 때문에 코드를 이해하고 분석하기 쉬워진다
- 사전조건
  - 메서드가 정상적으로 실행되기 위해 만족해야 하는 조건으로 메서드를 실행시키는 클라이언트의 의무이다
		
- 사후조건
  - 메서드의 실행 결과가 올바른지를 검사하고 실행 후에 객체가 유효한 상태로 남았는지를 검증
  - 사후조건 세가지 용도
    - 인스턴스 변수의 상태가 올바른지를 서술하기 위해
    - 메서드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해
    - 반환값이 올바른지를 서술하기 위해
- 불변식
  - 인스턴스 생명주기 전반에 걸쳐 지켜야 하는 규칙을 명세
  - 특성
    - 불변식은 클래스의 모든 인스턴스가 생성된 후에 만족돼야 한다. 이것은 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다는 것을 의미
    - 불변식은 클라이언트에 의해 호출 가능한 모든 메서드에 의해 준수돼야 한다. 메서드가 실행되는 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요는 없지만 메서드 실행 전과 종료 후에는 항상 불변식을 만족하는 상태가 유지돼야 한다

##### 계약에 의한 설계와 서브 타이핑

- 리스코프 치환 원칙 
  - 약 규칙은 슈퍼타입과 서브타입 사이의 사전조건, 사후조건, 불변식에 대해 서술할 수 있는 제약에 관한 규칙
    - 서브타입에 더 강력한 사전조건을 정의할 수 없다 
    - 서브타입에 더 완화된 사후조건을 정의할 수 없다
    - 슈퍼타입의 불변식은 서브타입에서도 유지돼야 한다
  - 가변성 규칙은 파라미터와 리턴 타입의 변형과 관련된 규칙
    - 서브타입의 메서드 파라미터는 반공변성을 가져야 한다
    - 서브타입의 리턴 타입은 공변성을 가져야 한다
    - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다

- 계약 규칙
  - 서브타입에 더 강력한 사전조건을 정의할 수 없다
    - 사전조건을 만족하는 것은 클라이언트
    - 서브타입이 슈퍼타입에 정의된 사전조건을 강화하면 클라이언트와 기존에 체결된 계약을 위반
    - 클라이언트가 계약서보다 지켜야할 조건이 강화된다면 받아들일 수 있을까
  - 서브타입에 더 완화된 사후조건을 정의할 수 없다
    - 사후조건은 서버에서 지켜야 할 조거으로 서브타입에서 완화된 사후조건으로 결과를 클라이언트에게 return한다면 클라이언트 입장에서는 적은 이익을 받게 되는 것으로 계약에 명시된 받아야 하는 결과 수준이 떨어지기 때문에 리코스프 치환 원칙에 위배된다
  - 슈퍼타입의 불변식은 서브타입에서도 유지돼야 한다
			
- 가변성 규칙
  - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다
    - 부모클래스가 던지는 예외가 속한 상속 계층이 아닌 다른 상속 계층에 속하는 예외를 던질 경우 자식클래스는 부모클래스를 대체할 수 없다
    - 자식클래스에서 부모클래스에서 정의하지 않는 예외를 발생시킬 수 없다
    - 자식클래스가 오버라이딩 하는 메서드에 기능을 퇴화시킬 수 없다
			
  - 서브타입의 리턴 타입은 공변성을 가져야 한다
    - 리턴타입 공변성
      - 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 부모 클래스에서 선언한 반환타입의 서브타입으로 지정할 수 있는 특성
      - 메서드를  구현한 클래스의 타입 계층 방향과 리턴 타입의 계층 방향이 동일한 경우를 가리킨다
  - 서브타입의 메서드 파라미터는 반공변성을 가져야 한다
    - 파라미터 타입 반공변성
      - 부모클래스에서 구현된 메서드를 자식클래스에서 오버라이딩할 때 파라미터 타입을 부모클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있는 특성
  - 참고
    - 공변성: S 와 T 사이의 서브타입 관계가 그대로 유지. 이 경우 해당 위치에서 서브타입인 S가 슈퍼타입인 T 대신 사용할 수 있다. 우리가 흔히 이야기하는 리스코프치환원칙은 공변성과 관련된 원칙이라고 할 수 있다
    - 반공변성:  S 와 T 사이의 서브타입 관계가 역전된다. 이 경우 해당 위치에서 슈퍼타입이 T가 서브타입인 S 대신 사용될 수 있다.
    - 무공변성: S 와 T 사이에는 아무런 관계도 존재하지 않는다. 따라서 S 대신 T를 사용하거나 T 대신 S를 사용할 수 없다
  - 함수 타입과 서브타이핑
    - 최근 객체지향 언어에서 이름없는 메서드를 정의할 수 있게 한다
      - 익명함수,함수 리터럴, 람다 표현식
    - 이름없는 메서드를 정의한 타입의 서브타입 정의, 오버라이딩 또한 가능하다
      - 파라미터 타입의 반공변성, 리턴타입의 공변성을 갖으면 오버라이딩은 가능하다