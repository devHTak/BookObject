#### 객체 분해

##### 프로시저 추상화와 데이터 추상화
- 현대적인 프로그래밍 언어를 특정 짓는 중요한 두 가지 추사화 메커니즘
- 프로시저 추상화
  - 프로시저 추상화는 소프트웨어가 무엇을 해야하는 지를 추상화한다
  - 프로시저 추상화를 중심으로 시스템을 분해하기로 했다면 기능분해를 해야 한다.
- 데이터 추상화
  - 데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화한다.
  - 데이터 추상화를 중심으로 시스템을 분해하기로 했다면 두 가지중 하나를 선택해야 한다.
    - 타입 추상화: 추상 데이터 타입
    - 프로시저 추상화: 객체지향
- 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다

##### 프로시저 추상화와 기능 분해
- 메인함수로서의 시스템
  - 프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법
  - 프로시저는 잠재적으로 정보은닉을 제공하지만 효과적으로 구축하는 데 한계가 있다.
  - 전통적인 기능 분해 방법은 하향식 접근법을 따른다.
    - 시스템을 구성하는 가장 최상위 기능을 정의, 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.

- 급여관리 시스템
  - 연초에 회사는 매달 지급해야 하는 기본급에 대해 직원과 협의
  - 해당 금액을 12개월 동안 동일하게 직원에게 지급하며 소득세를 제외한 금액을 제공한다.
    - 급여 = 기본급 - (기본급 * 소득세율)
  - 급여관리 시스템에 대한 추상적인 최상위 문장
    - 직원의 급여를 계산한다
  - 세부적인 절차로 구체화
    - 사용자로부터 소득세율을 입력받는다
      - "세율을 입력하세요: " 라는 문장을 화면에 출력
      - 키보드를 통해 세율을 입력 받는다
    - 직원의 급여를 계산
      - 전역 변수에 저장된 직원의 기본급 정보를 얻는다
      - 급여를 계산한다
    - 양식에 맞게 결과를 출력
      - "이름: {직원명}, 급여: {계산된 급여}" 형식에 따라 출력 문자열을 생성
  - 기능분해 방법에서 기능을 중심으로 필요한 데이터를 결정한다
    - 기능분해를 위한 하햐익 접근법을 먼저 필요한 기능을 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다
    - 유지보수에 다양한 문제점을 야기한다.
- 기능 구현 
  - 하향식 기능 분해는 논리적이고 체계적인 시스템 개발 절차를 제시한다.
  - 하지만 현실세계는 불규칙하기 때문에 만나는 지점에서 혼란과 동요가 발생한다
- 하향식 기능분해의 문제점
  - 결과적으로 모든 문제의 원인은 결합도
    - 상위 함수와 강하게 결합되기 때문에 시스템 변경, 이해하기 어렵게 한다
  - 하나의 메인함수라는 비현실적인 아이디어
    - 새로운 요구사항이 발생하거나 기능이 추가되면 하나의 메인 함수는 단순한 하나의 기능으로 역할을 하게 된다.
    - 하나의 알고리즘을 구현하거나 배치 처리에는 적합하지만 현대적인 상호작용 시스템과는 적합하지 않다.
  - 메인 함수의 빈번한 재설계
    - 하나의 메인함수를 갖게되면 새로운 기능을 추가할 때마다 메인 함수를 매번 수정해야 한다.
  - 비즈니스 로직과 사용자 인터페이스의 결합
    - 설계 초기단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다
    - 문제는 비즈니스 로직보다 사용자 인터페이스가 더 자주 변경된다.
  - 성급하게 결정된 실행 순서
    - 하나의 함수를 더 작은 함수로 분해하고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약할 수 있다.
    - 이는 시스템이 무엇을 해야 하는지가 아니라 어떻게 동작해야 하는지에 집중하도록 한다
  - 데이터 변경으로 인한 파급효과
		
- 언제 하향식 분해가 유용한가 
  - 작은 프로그램, 개별 알고리즘을 위해서는 유용

##### 모듈
- 정보 은닉과 모듈
  - 기능을 기반으로 시스템을 분해하는 것이 아닌 변경의 방향에 맞춰 시스템 분해
  - 정보 은닉
    - 시스템을 모듈단위로 분해하기 위한 기본 원리
    - 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심
  - 시스템을 모듈로 분해한 후, 각 모듈 내부를 구현하기 위해 기능 분해 적용
  - 모듈은 두가지 비밀을 감춰야 한다
    - 복잡성: 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.
    - 변경 가능성: 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공
  - 모듈에서 가장 일반적인 비밀은 데이터 > 복잡한 로직 > 변경 가능성이 있는 자료 구조

- 모듈의 장점과 한계
  - 모듈의 장점
    - 모듈 내부의 변수가 변경되더라도 모듈 내무에만 영향을 미친다
    - 비즈니스 로직과 사용자 인터페이스에 대한 관심사 분리
    - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염 방지
  - 모듈은 기능이 아닌 변경 정도에 따라 시스템을 분해
    - 모듈 내부에 관련성 높은 데이터, 함수의 집합 -> 높은 응집도
    - 모듈과 모듈 사이에 퍼블릭 인터페이스를 통해서 통신 -> 낮은 결합도
  - 모듈의 단점은 인스턴스의 개념을 제공하지 않는 것이다.
    - Employee 모듈은 단지 회사에 속한 모든 직원 정보를 갖고 있는 모듈일 뿐이다.
    - 좀 더 높은 추상화를 위해서는 직원 전체가 아닌 개별 직원을 독립적인 단위로 다룰 수 있어야 한다.

##### 데이터 추상화와 추상 데이터 타입

- 추상 데이터 타입
  - 추상데이터 타입 구현에 필요한 것
    - 타입 정의를 선언할 수 있어야 한다
    - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
    - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다
    - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.
  - 추상 데이터 타입은 시스템의 상태를 저장할 데이터를 표현하며 표현된 데이터를 이용하여 기능을 구현하는 핵심 로직은 추상 데이터 타입 외부에 존재한다.
    - 즉, 데이터와 기능을이 분리하는 절차적인 설게의 틀에 갇혀 있는 것

##### 클래스
- 클래스는 추상 데이터 타입인가?
  - 클래스와 추상 데이터 타입은 동일하지 않다.
    - 상속과 다형성
  - 추상 데이터 타입은 타입을 추상화한 것, 클래스는 절차를 추상화한 것이라고 할 수 있다.
  - 추상 데이터 타입이 오퍼레이션을 기준으로 타입을 묶는 방법이라면 객체지향은 타입을 기준으로 오퍼레이션을 묶는다
    - Employee 는 정직원, 아르바이트 직원으로 나뉠 수 있다.
    - 추상 데이터 타입은 두 개의 타입을 명시적으로 정의, 두 직원 유형에 대한 오퍼레이션을 분배한다
    - 클래스는 공통 로직을 정의한 부모 클래스와 두 직원 유형의 클래스를 상속받도록 생성(다형성)

- 변경을 기준으로 선택하라
  - 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향 위반으로 간주된다
  - 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.
  - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 것을 OCP(Open-Closed Principle)이라 한다
  - 추상 데이터 타입과 객체지향 설계의 유용성
    - 설계에 요구되는 변경의 압력이 타입 추가에 관한 것이라면 객체 지향 설계
    - 설계에 요구되는 변경의 압력이 오퍼레이션 추가하는 것이라면 추상 데이터 타입

- 협력이 중요하다